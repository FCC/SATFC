#! /usr/bin/env python
# vim: syntax=python
import sys
import os
import time
import subprocess
import socket
import logging

version = '0.9.6a'
date = 'August 2013'
solver = 'Daemon SATFC Tuned Clasp Library'
"""
SAT-based Feasibility checker for FCC's station repacking problem.
Wrapper that communicates with a more parametrized java version of the feasibility checker running as a daemon,
to comform to Ladder Auction Algorithm Mini-Spec v2.1, June 2013 feasibility
checker requirements.

By Auctionomics [Alexandre Frechette, Guillaume Saulnier-Comte, Nick Arnosti, Kevin Leyton-Brown]

@author - Alexandre Frechette
"""

"""Static daemon solver communication parameters"""
UDP_IP = "localhost"
UDP_PORT = 49149
MAXPACKETSIZE = 65000

COMMANDSEP = ':'

"""Static daemon solver parameters"""
#(relative) path to clasp library to launch daemon with.
DAEMONSOLVERLIB = 'SATsolvers/clasp/jna/libjnaclasp.so'
#Seed used whenever we're solving a problem.
SEED=str(1)

"""Waiting variables"""
#Maximum time (s) we wait for a ping message.
MAXPINGTIME = 1
#Time (s) added to the cutoff time as a timeout when waiting for a solving.
SOLVINGWAITADDEDTIME = 30
#The time (s) waited in initialization phase to insure the daemon has started carefully.
DAEMONCREATIONSANITYSLEEPTIME = 4

"""Setup logging"""
logging.basicConfig(format='%(asctime)s.%(msecs).03d [%(levelname)s] %(message)s',
                    level=logging.DEBUG,
                    datefmt='%d/%m/%Y %H:%M:%S')

#########################################################################################################

def establishConnection():
    """Establish connection"""
    logging.debug('Establishing connection.')
    try:
        sock = socket.socket(socket.AF_INET, # Internet
                        socket.SOCK_DGRAM) # UDP
        return sock
    except Exception as e:
        raise Exception('Could not create a UDP socket ('+str(e)+').')

def processMessage(message):
    command = message.split(COMMANDSEP)[0]

    if command == 'PING':
        logging.debug('Got a PING message.')
        return ('PING','')
    if command == 'IGNORE':
        return ('IGNORE','')
    elif command == 'ERROR':
        logging.warning('Got an ERROR message:')
        messageparts = message.split(COMMANDSEP)
        if len(messageparts)==2:
            logging.warning('Server error: %s',messageparts[1])
        else:
            logging.warning('(No error info with the error message)')
        return ('ERROR','')
    elif command == 'ANSWER':
        logging.debug('Got an ANSWER message.')
        messageparts = message.split(COMMANDSEP)
        if len(messageparts)==2:
            resultstring = messageparts[1]
            resultstringparts = resultstring.split(',')
            if len(resultstringparts)==3:
                satisfiability = resultstringparts[0]
                if satisfiability=='SAT':
                    satisfiability = 'yes'
                elif satisfiability=='UNSAT':
                    satisfiability = 'no'
                else:
                    satisfiability = 'unknown'

                runtime = resultstringparts[1]
                runtime = "%0.4f" % float(runtime)

                assignment = resultstringparts[2]
                if satisfiability == 'yes':
                    assignment = {s[0]:s[1].split('_') for s in [seg.split('-') for seg in assignment.split(';')]}
                else:
                    assignment = {}

                return ('ANSWER',(satisfiability,runtime,assignment))
            else:
                logging.error('Could not parse result string from SATFC.')
                logging.error('Received: %s',message)
                return ('ERROR',message)
        else:
            logging.error('Could not parse answer received from daemon SATFC.')
            logging.error('Received: %s',message)
            return ('ERROR',message)

    elif command == 'TEST':
        logging.debug('Got a TEST message:')
        logging.debug('%s',message)
        return ('TEST','')
    else:
        logging.error('Unrecognized message:')
        logging.error('%s',message)
        return ('UNRECOGNIZED',message)

def sendMessage(sock,message):
    try:
        if len(message)>100:
            logging.debug('Sending "%s ...',message[0:100])
        else:
            logging.debug('Sending "%s".',message)
        sock.sendto(message.encode('ASCII'), (UDP_IP, UDP_PORT))
    except Exception as e:
        logging.error('Could not send message to %s port %s (%s).',str(UDP_IP),str(UDP_PORT),str(e))

def receiveMessage(sock,timeout):
    sock.settimeout(timeout)
    try:
        message, addr = sock.recvfrom(MAXPACKETSIZE)
        logging.debug('Received a message.')
        return message
    except Exception as e:
        logging.warning('Error while waiting for packet (%s).',str(e))
        return 'IGNORE'

def ping(sock):
    pingtime = time.time()
    pinged = False
    while not pinged and time.time()-pingtime < MAXPINGTIME:
        sendMessage(sock,'PING')
        message = receiveMessage(sock,MAXPINGTIME)
        (messagetype,messageinfo) = processMessage(message)
        pinged = (messagetype=='PING')
    return pinged

#########################################################################################################

def main():
    starttime = time.time()
    """Check what command must be executed"""
    if len(sys.argv)<=1:
        #Output usage.
        print 'SATFC '+date+', v'+version
        print 'A SAT-based feasibility checker by Auctionomics [A. Frechette, G. Saulnier-Comte, N. Arnosti, K. Leyton-Brown]'
        print 'Normal execution: "./feas_check question_csv_file_name answer_csv_file_name"'
        print 'This wrapper communicates with a SATFC daemon on ',UDP_IP,'port',UDP_PORT
        print 'For more usage see feasibility checker usage section of the Ladder Auction Algorithm Mini-Spec v2.1, June 2013.'
        return
    elif sys.argv[1]=='-init':
        """Initialization to perform"""
        logging.info('Performing initialization.')
        (current_dir,environment_data_location,environment_execution_dir) = getEnvironmentVariables()
        sock = establishConnection()
        init(sock,current_dir)
        logging.info('Done.')
        return
    elif sys.argv[1]=='-kill':
        """Killing daemon SATFC"""
        logging.info('Killing daemon solver.')
        sock = establishConnection()
        logging.debug('Checking that the daemon SATFC is alive.')
        pinged = ping(sock)
        if not pinged:
            logging.info('SATFC daemon did not answer ping, assuming already dead.')
        else:
            logging.info('Daemon SATFC is alive, sending a kill command.')
            sendMessage(sock,'TERMINATE')
        logging.info('Done.')
        return
    elif len(sys.argv)!=3:
        print 'Unrecognized usage, try ./feas_check for some info.'
        return
    else:
        run_information = []

        run_information.append('SATFC v'+version+' using '+solver+'.')

        """Setup the instance to solve"""
        logging.debug('Reading instance information.')
        (current_dir,environment_data_location,environment_execution_dir) = getEnvironmentVariables()

        (question_filename,answer_filename,problem_data_directory,packing_stations,packing_channels,cutoff) = getSolvingInstanceInfo(environment_execution_dir,environment_data_location)

        instance = '-'.join(packing_channels)+'_'+'-'.join(packing_stations)

        """Establish connection"""
        sock = establishConnection()

        """Init if not available."""
        init(sock,current_dir)
        logging.info('Daemon SATFC is alive, proceeding.')

        """Create the solving message."""
        logging.info('Submitting an instance to the daemon SATFC')
        logging.debug('Solving instance: %s ,',instance)
        logging.debug('with cutoff %s ,',cutoff)
        logging.debug('and seed %s .',SEED)
        """Send message."""
        sendMessage(sock,COMMANDSEP.join(['SOLVE',problem_data_directory,instance,cutoff,SEED]))

        """Wait for answer"""
        logging.info('Waiting for an answer...')
        solvetime = time.time()
        solved=False
        while not solved and time.time()-solvetime < (SOLVINGWAITADDEDTIME+float(cutoff)):
            message = receiveMessage(sock,(SOLVINGWAITADDEDTIME+float(cutoff)))
            (messagetype,messageinfo) = processMessage(message)
            solved = (messagetype=='ANSWER')
            error = (messagetype=='ERROR')
            if not solved:
                run_information.append('Message received during solving: "'+message+'"')
            if error:
                break

        if solved:
            (satisfiability,runtime,assignment) = messageinfo
        else:
            logging.error('Instance was not solved within allocated time.')
            satisfiability = 'unknown'
            runtime = time.time()-starttime
            assignment = {}

        logging.info('Result: %s',','.join([str(satisfiability),str(runtime),str(assignment)]))

        totaltime = time.time()-starttime
        run_information.append('Total time taken '+str(totaltime)+' seconds.')
        run_information.append('Time spent solving by daemon SATFC '+str(runtime)+' seconds.')

        logging.info('Total walltime taken: %s',str(totaltime))

        logging.info('Writing result to file %s',answer_filename)

        answer_file = open(answer_filename,'w')
        answer_file.write('ANSWER,'+satisfiability+'\n')
        for information_line in run_information:
            answer_file.write('FC_INFO,'+information_line+'\n')
        for channel in assignment.keys():
            for station in assignment[channel]:
                answer_file.write(str(station)+','+str(channel)+'\n')
        answer_file.close()
        return


#########################################################################################################

def getEnvironmentVariables():
    """Environment variables and external settings"""
    #Execution directory of feas_check
    current_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

    #Get the necessary environment variables
    environment_variables = os.environ
    if 'FC_STATION_DATA_PATH' in environment_variables:
        environment_data_location = environment_variables['FC_STATION_DATA_PATH']
    else:
        logging.warning('FC_STATION_DATA_PATH environment variable has not been set, resolving to default current directory.')
        environment_data_location = current_dir
    environment_data_location = environment_data_location.rstrip(os.sep)

    if 'FC_WORKING_PATH' in environment_variables:
        environment_execution_dir = environment_variables['FC_WORKING_PATH']
    else:
        logging.warning('FC_WORKING_PATH environment variable has not been set, resolving to default current directory.')
        environment_execution_dir = current_dir
    environment_execution_dir = environment_execution_dir.rstrip(os.sep)

    return (current_dir,environment_data_location,environment_execution_dir)

def getSolvingInstanceInfo(environment_execution_dir,environment_data_location):
    """Parse FCC feas_check parameters"""

    question_filename = environment_execution_dir+os.sep+sys.argv[1]
    answer_filename = environment_execution_dir+os.sep+sys.argv[2]

    #Parse the question parameters
    question_parameters = {}
    question_file = open(question_filename,'r')
    question_lines = question_file.readlines()
    question_file.close()

    question_parameters = {'FC_TIMEOUT':[],'FC_CONFIG':[],'STATION_CONFIG':[],'BAND':[],'HIGHEST':[],'STATIONS':[]}

    for question_line in question_lines:
        question_line = question_line.replace('\n','')
        key = question_line.split(',')[0]
        if key in question_parameters.keys():
            question_parameters[key].append(question_line.split(',')[1])
        elif key.isdigit():
            question_parameters['STATIONS'].append(question_line)
        elif key:
            raise Exception('Unrecognized problem instance data key in question csv file! ('+question_line+')')

    #Map to options for feasibility checker.
    try:
        cutoff = str(float(question_parameters['FC_TIMEOUT'][0])/1000.0)
    except:
        raise Exception('Unrecognized value for key FC_TIMEOUT in question csv file!')

    #Directory to find problem setting data
    problem_data_directory = 'default'
    if len(question_parameters['STATION_CONFIG'])>0:
        problem_data_directory = question_parameters['STATION_CONFIG'][0]
    problem_data_directory = environment_data_location+os.sep+problem_data_directory

    #Channels to pack into.
    if question_parameters['BAND'][0]=='LVHF':
        packing_channels = range(2,6+1)
    elif question_parameters['BAND'][0]=='HVHF' or question_parameters['BAND'][0]=='UVHF':
        packing_channels = range(7,13+1)
    elif question_parameters['BAND'][0]=='UHF':

        highest_channel = 51
        if len(question_parameters['HIGHEST'])>0:
            try:
                highest_channel = int(question_parameters['HIGHEST'][0])
            except:
                raise Exception('Unrecognized value for key HIGHEST in question csv file! (value ='+question_parameters['HIGHEST']+')')

        packing_channels = range(14,min(highest_channel,51)+1)
        if 37 in packing_channels:
            packing_channels.remove(37)
    else:
        raise Exception('Unrecognized value for key BAND in question csv file! (value = '+question_parameters['BAND']+')')
    packing_channels = [str(c) for c in packing_channels]

    #Stations to pack
    try:
        packing_stations = [int(line.split(',')[0]) for line in question_parameters['STATIONS']]
    except:
        raise Exception('Unrecognized list of stations in question csv file! ('+question_parameters['STATIONS']+')')
    packing_stations = [str(s) for s in packing_stations]

    return (question_filename,answer_filename,problem_data_directory,packing_stations,packing_channels,cutoff)

def init(sock,current_dir):
    #Perform initialization
    #Check if daemon SATFC is alive.
    logging.debug('Checking that the daemon SATFC is alive.')
    pinged = ping(sock)
    if pinged:
        logging.debug('Daemon SATFC is already alive, no initialization needed.')
        return
    logging.info('Daemon SATFC unavailable.')
    logging.info('Launching daemon SATFC.')

    #Navigate the current directory for data folders.
    logging.debug('Gathering all the available data folders.')
    datafoldernames = []
    for subdirectory in [d for d in os.listdir(current_dir) if os.path.isdir(d)]:
        if os.path.isfile(current_dir+os.sep+subdirectory+os.sep+'domains.csv') and os.path.isfile(current_dir+os.sep+subdirectory+os.sep+'interferences.csv'):
            logging.debug('Data available in %s',subdirectory)
            datafoldernames.append(current_dir+os.sep+subdirectory)

    if len(datafoldernames)==0:
        logging.warning('There were no valid FC_CONFIG data folders in %s',current_dir)
        logging.warning('SATFC daemon will be started without any data.')
    elif len(datafoldernames)<5:
        logging.debug('SATFC daemon will be started with data from: %s',','.join(datafoldernames))
    else:
        logging.debug('SATFC daemon will be started with more than 5 different data sets.')

    """Fill in the SATFC_daemon options and launch it"""
    options = {
    '--library':current_dir+os.sep+DAEMONSOLVERLIB,
    '-PORT':str(UDP_PORT),
    '-DATA-FOLDERNAME':'"'+','.join(datafoldernames)+'"'
    }

    feas_check_exec = 'java -jar '+current_dir+os.sep+'SATFC_daemon.jar'
    options_callstring = ' '.join(map(lambda (k,v) : k+' '+v,options.iteritems()))
    callstring = feas_check_exec+' '+options_callstring

    logging.info('Launching SATFC daemon.')
    logging.debug('Executing : %s',callstring)

    daemon_out_name = 'SATFC_daemon_out.txt'
    daemon_out = open(daemon_out_name,'w')
    daemon_err_name = 'SATFC_daemon_err.txt'
    daemon_err = open(daemon_err_name,'w')

    execution = subprocess.Popen(callstring.split(' '),stdout=daemon_out, stderr=daemon_err, stdin=subprocess.PIPE)

    #Sanity check, make sure standard error is empty after 5 seconds.
    logging.info('Making sure daemon solver was started without any errors... ')
    time.sleep(DAEMONCREATIONSANITYSLEEPTIME)
    errors=open(daemon_err_name,'r').readlines()
    if not len(errors)==0:
        execution.kill()
        logging.error('There was an error while starting the daemon solver.')
        logging.error('Check %s and %s .',daemon_out_name,daemon_err_name)
        logging.error('Make sure to kill the SATFC_daemon process if it is not already dead.')

        logging.error('Sample of',daemon_err_name,':')
        logging.error('========================================================================')
        for i in range(min(10,len(errors))):
            logging.error('%s',errors[i])
        logging.error('========================================================================')
        raise Exception('There was an error while starting the daemon solver.')

    else:
        logging.info('SATFC daemon started on port %s and ready to go.',str(UDP_PORT))

    return

if __name__ == "__main__":
    main()
    sys.exit()
