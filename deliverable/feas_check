#! /usr/bin/env python
# vim: syntax=python

import subprocess
import sys
import os
import tempfile
import time
import socket
import select

version = '0.9.6a'
date = 'August 2013'
solver = 'Daemon SATFC Tuned Clasp Library'
"""
SAT-based Feasibility checker for FCC's station repacking problem.
Wrapper that communicates with a more parametrized java version of the feasibility checker running as a daemon,
to comform to Ladder Auction Algorithm Mini-Spec v2.1, June 2013 feasibility
checker requirements.

By Auctionomics [Alexandre Frechette, Guillaume Saulnier-Comte, Nick Arnosti, Kevin Leyton-Brown]

@author - Alexandre Frechette
"""

"""Static daemon solver communication parameters"""
UDP_IP = "localhost"
UDP_PORT = 49149
MAXPACKETSIZE = 65000

COMMANDSEP = ':'

"""Static daemon solver parameters"""
DAEMONSOLVERLIB = 'SATsolvers/clasp/jna/libjnaclasp.so'
SEED=str(1)

"""Waiting variables"""
#Maximum number of times we attempt to ping the SATFC daemon before reperforming initialization.
MAXPINGATTEMPS=1
#Maximum time (s) we wait for a ping message.
MAXPINGTIME = 1
#Fraction of cutoff time we wait for an answer to solve message.
MAXCUTOFFFRACTIONWAITTIME = 1.5
#The time (s) waited in initialization phase to insure the daemon has started carefully.
DAEMONCREATIONSANITYSLEEPTIME = 2

#########################################################################################################

def processMessage(message):
    command = message.split(COMMANDSEP)[0]
    
    if command == 'PING':
        print '[COMM] Got a PING message.'
        return ('PING','')
    if command == 'IGNORE':
        return ('IGNORE','')
    elif command == 'ERROR':
        print '[COMM] Got an ERROR message:'
        messageparts = message.split(COMMANDSEP)
        if len(messageparts)==2:
            print '[SERVER-ERROR]',messageparts[1]
        else:
            print '(No error info with the error message)'
        return ('ERROR','')
    elif command == 'ANSWER':
        print '[COMM] Got an ANSWER message.'
        messageparts = message.split(COMMANDSEP)
        if len(messageparts)==2:
            resultstring = messageparts[1]
            resultstringparts = resultstring.split(',')
            if len(resultstringparts)==3:
                satisfiability = resultstringparts[0]
                if satisfiability=='SAT':
                    satisfiability = 'yes'
                elif satisfiability=='UNSAT':
                    satisfiability = 'no'
                else:
                    satisfiability = 'unknown'
                    
                runtime = resultstringparts[1]
                runtime = "%0.4f" % float(runtime)
  
                assignment = resultstringparts[2]          
                if satisfiability == 'yes':
                    assignment = {s[0]:s[1].split('_') for s in [seg.split('-') for seg in assignment.split(';')]}
                else:
                    assignment = {}
                
                return ('ANSWER',(satisfiability,runtime,assignment))
            else:
                print '[COMM-ERROR] Could not parse result string from SATFC.'
                print '[COMM-ERROR] Received:',message
                return ('ERROR',message)
        else:
            print '[COMM-ERROR] Could not parse answer received from daemon SATFC.'
            print '[COMM-ERROR] Received:',message
            return ('ERROR',message)
            
    elif command == 'TEST':
        print '[COMM] Got a TEST message.'
        print message
        return ('TEST','')
    else:
        print '[COMM-ERROR] Unrecognized message:'
        print '[COMM-ERROR]',message
        return ('UNRECOGNIZED',message)
    
def sendMessage(sock,message):
    try:
        if len(message)>120:
            print '[COMM] Sending',message[0:120],'...'
        else:
            print '[COMM] Sending',message
        sock.sendto(message.encode('ASCII'), (UDP_IP, UDP_PORT))
    except Exception as e:
        print '[COMM-ERROR] Could not send message to',UDP_IP,'port',UDP_PORT,'('+str(e)+').'
    
def receiveMessage(sock,timeout):
    sock.settimeout(timeout)
    try:
        message, addr = sock.recvfrom(MAXPACKETSIZE)
        print '[COMM] Received a message.'
        return message
    except Exception as e:
        print '[COMM-ERROR] Error while waiting for packet ('+str(e)+').'
        return 'IGNORE'
        

    
#########################################################################################################

def main():
    starttime = time.time()
  
    """Check what command must be executed"""
    if len(sys.argv)<=1:
        #Output usage.
        print 'SATFC '+date+', v'+version
        print 'A SAT-based feasibility checker by Auctionomics [A. Frechette, G. Saulnier-Comte, N. Arnosti, K. Leyton-Brown]'
        print 'Normal execution: "./feas_check question_csv_file_name answer_csv_file_name"'
        print 'This wrapper communicates with a SATFC daemon on ',UDP_IP,'port',UDP_PORT
        print 'For more usage see feasibility checker usage section of the Ladder Auction Algorithm Mini-Spec v2.1, June 2013.'
        sys.exit()
    elif sys.argv[1]=='-init':
        """Initialization to perform"""
        print '[INFO] Performing initialization.'
        (current_dir,environment_data_location,environment_execution_dir) = getEnvironmentVariables()
        
        """Establish connection"""
        print '[INFO] Establishing connection.'
        try:
            sock = socket.socket(socket.AF_INET, # Internet
                             socket.SOCK_DGRAM) # UDP
        except Exception as e:
            raise Exception('[ERROR] Could not create a UDP socket ('+str(e)+').')
        
        init(sock,current_dir)    
        sys.exit()
    elif len(sys.argv)!=3:
        print 'Unrecognized usage, try ./feas_check for some info.'
        sys.exit()
    else:  
        run_information = []
               
        run_information.append('SATFC v'+version+' using '+solver+'.')
        
        """Setup the instance to solve"""
        print '[INFO] Reading instance information.'
        (current_dir,environment_data_location,environment_execution_dir) = getEnvironmentVariables()
        
        (question_filename,answer_filename,problem_data_directory,packing_stations,packing_channels,cutoff) = getSolvingInstanceInfo(environment_execution_dir,environment_data_location)
        
        instance = '-'.join(packing_channels)+'_'+'-'.join(packing_stations)
        
        """Establish connection"""
        print '[INFO] Establishing connection.'
        try:
            sock = socket.socket(socket.AF_INET, # Internet
                             socket.SOCK_DGRAM) # UDP
        except Exception as e:
            raise Exception('[ERROR] Could not create a UDP socket ('+str(e)+').')
        
        """Ping daemon"""
        init(sock,current_dir)
        print '[INFO] Daemon SATFC is alive, proceeding.'   
        
        """Create the solving message."""
        print '[INFO] Submitting an instance to the daemon SATFC'
        
        """Send message."""
        sendMessage(sock,COMMANDSEP.join(['SOLVE',problem_data_directory,instance,cutoff,SEED]))
        
        """Wait for answer"""
        print '[INFO] Waiting for an answer...'
        solvetime = time.time()
        solved=False        
        while not solved and time.time()-solvetime < MAXCUTOFFFRACTIONWAITTIME*float(cutoff):           
            message = receiveMessage(sock,MAXCUTOFFFRACTIONWAITTIME*float(cutoff))
            (messagetype,messageinfo) = processMessage(message)
            solved = (messagetype=='ANSWER')
             
        if solved:
            (satisfiability,runtime,assignment) = messageinfo
        else:
            print '[ERROR] Instance was not solved within '+str(MAXCUTOFFFRACTIONWAITTIME)+'*cutofftime ('+str(MAXCUTOFFFRACTIONWAITTIME*float(cutoff))+') assuming something terrible happened.'                        
            satisfiability = 'unknown'
            runtime = time.time()-starttime
            assignment = {}
        
        print '[INFO] Result:',','.join([str(satisfiability),str(runtime),str(assignment)])
        
        totaltime = time.time()-starttime
        run_information.append('Total time taken '+str(totaltime)+' seconds.')
        run_information.append('Time spent solving by daemon SATFC '+str(runtime)+' seconds.')
        
        print '[INFO] Total walltime taken:',str(totaltime)
        
        print '[INFO] Writing result to file',answer_filename
        
        answer_file = open(answer_filename,'w')
        answer_file.write('ANSWER,'+satisfiability+'\n')
        for information_line in run_information:
            answer_file.write('FC_INFO,'+information_line+'\n')
        for channel in assignment.keys():
            for station in assignment[channel]:
                answer_file.write(str(station)+','+str(channel)+'\n')
        answer_file.close()
            
        sys.exit()

        
#########################################################################################################

def getEnvironmentVariables():
    """Environment variables and external settings"""
    #Execution directory of feas_check
    current_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

    #Get the necessary environment variables
    environment_variables = os.environ
    if 'FC_STATION_DATA_PATH' in environment_variables:
        environment_data_location = environment_variables['FC_STATION_DATA_PATH']
    else:
        print '[WARNING] FC_STATION_DATA_PATH environment variable has not been set, resolving to default current directory.'
        environment_data_location = current_dir
    environment_data_location = environment_data_location.rstrip(os.sep)

    if 'FC_WORKING_PATH' in environment_variables:
        environment_execution_dir = environment_variables['FC_WORKING_PATH']
    else:
        print '[WARNING] FC_WORKING_PATH environment variable has not been set, resolving to default current directory.'
        environment_execution_dir = current_dir
    environment_execution_dir = environment_execution_dir.rstrip(os.sep)
    
    return (current_dir,environment_data_location,environment_execution_dir)
    
def getSolvingInstanceInfo(environment_execution_dir,environment_data_location):
    """Parse FCC feas_check parameters"""

    question_filename = environment_execution_dir+os.sep+sys.argv[1]
    answer_filename = environment_execution_dir+os.sep+sys.argv[2]

    #Parse the question parameters
    question_parameters = {}
    question_file = open(question_filename,'r')
    question_lines = question_file.readlines()
    question_file.close()

    question_parameters = {'FC_TIMEOUT':[],'FC_CONFIG':[],'STATION_CONFIG':[],'BAND':[],'HIGHEST':[],'STATIONS':[]}

    for question_line in question_lines:
        question_line = question_line.replace('\n','')
        key = question_line.split(',')[0]
        if key in question_parameters.keys():
            question_parameters[key].append(question_line.split(',')[1])
        elif key.isdigit():
            question_parameters['STATIONS'].append(question_line)
        elif key:
            raise Exception('Unrecognized problem instance data key in question csv file! ('+question_line+')')

    #Map to options for feasibility checker.
    try:
        cutoff = str(float(question_parameters['FC_TIMEOUT'][0])/1000.0)
    except:
        raise Exception('Unrecognized value for key FC_TIMEOUT in question csv file!')

    #Directory to find problem setting data
    problem_data_directory = 'default'
    if len(question_parameters['STATION_CONFIG'])>0:
        problem_data_directory = question_parameters['STATION_CONFIG'][0]
    problem_data_directory = environment_data_location+os.sep+problem_data_directory

    #Channels to pack into.
    if question_parameters['BAND'][0]=='LVHF':
        packing_channels = range(2,6+1)
    elif question_parameters['BAND'][0]=='HVHF' or question_parameters['BAND'][0]=='UVHF':
        packing_channels = range(7,13+1)
    elif question_parameters['BAND'][0]=='UHF':

        highest_channel = 51
        if len(question_parameters['HIGHEST'])>0:
            try:
                highest_channel = int(question_parameters['HIGHEST'][0])
            except:
                raise Exception('Unrecognized value for key HIGHEST in question csv file! (value ='+question_parameters['HIGHEST']+')')

        packing_channels = range(14,min(highest_channel,51)+1)
        if 37 in packing_channels:
            packing_channels.remove(37)
    else:
        raise Exception('Unrecognized value for key BAND in question csv file! (value = '+question_parameters['BAND']+')')
    packing_channels = [str(c) for c in packing_channels]
    
    #Stations to pack
    try:
        packing_stations = [int(line.split(',')[0]) for line in question_parameters['STATIONS']]
    except:
        raise Exception('Unrecognized list of stations in question csv file! ('+question_parameters['STATIONS']+')')
    packing_stations = [str(s) for s in packing_stations]
    
    return (question_filename,answer_filename,problem_data_directory,packing_stations,packing_channels,cutoff)

def init(sock,current_dir):
    #Perform initialization        
    #Check if daemon SATFC is alive.
    print '[INFO] Checking that the daemon SATFC is alive.'
    pingtime = time.time()
    pinged = False
    while not pinged and time.time()-pingtime < MAXPINGTIME:
        sendMessage(sock,'PING')
        message = receiveMessage(sock,MAXPINGTIME)
        (messagetype,messageinfo) = processMessage(message)
        pinged = (messagetype=='PING')
        
    if pinged:
        print '[INFO] Daemon SATFC is already alive, no initialization needed.'
        return
    print '[INFO] Daemon SATFC unavailable.'        
    print '[INFO] Launching daemon SATFC.'
    
    #Navigate the current directory for data folders.
    print '[INFO] Gathering all the available data folders.'    
    datafoldernames = []
    for subdirectory in [d for d in os.listdir(current_dir) if os.path.isdir(d)]:
        if os.path.isfile(current_dir+os.sep+subdirectory+os.sep+'domains.csv') and os.path.isfile(current_dir+os.sep+subdirectory+os.sep+'interferences.csv'):
            print '[INFO] Data available in',subdirectory
            datafoldernames.append(current_dir+os.sep+subdirectory)

    if len(datafoldernames)==0:
        print '[WARN] There were no valid FC_CONFIG data folders in',current_dir
        print '[WARN] SATFC daemon will be started without any data.'
    elif len(datafoldernames)<5:
        print '[INFO] SATFC daemon will be started with data from',str(datafoldernames)
    else:
        print '[INFO] SATFC daemon will be started with more than 5 different data sets.'
        
    """Fill in the SATFC_daemon options and launch it"""
    options = {
    '--library':current_dir+os.sep+DAEMONSOLVERLIB,
    '-PORT':str(UDP_PORT),
    '-DATA-FOLDERNAME':'"'+','.join(datafoldernames)+'"'
    }
    
    feas_check_exec = 'java -jar '+current_dir+os.sep+'SATFC_daemon.jar'
    options_callstring = ' '.join(map(lambda (k,v) : k+' '+v,options.iteritems()))
    callstring = feas_check_exec+' '+options_callstring
    
    print '[INFO] Launching SATFC daemon, executing:'
    print callstring
    
    daemon_out_name = 'SATFC_daemon_out.txt'
    daemon_out = open(daemon_out_name,'w')
    daemon_err_name = 'SATFC_daemon_err.txt'
    daemon_err = open(daemon_err_name,'w')
    
    execution = subprocess.Popen(callstring.split(' '),stdout=daemon_out, stderr=daemon_err, stdin=subprocess.PIPE)
    
    #Sanity check, make sure standard error is empty after 5 seconds.
    print '[INFO] Making sure daemon solver was started without any errors... '
    time.sleep(DAEMONCREATIONSANITYSLEEPTIME)
    errors=open(daemon_err_name,'r').readlines()
    if not len(errors)==0:
        execution.kill()
        print '[ERROR] There was an error while starting the daemon solver.'
        print '[ERROR] Check SATFC_daemon_out.txt and SATFC_daemon_err.txt.'
        print '[ERROR] Make sure to kill the SATFC_daemon process if it is not already dead.'
        
        print '[ERROR] Sample from',daemon_err_name,':'
        print '========================================================================'
        print ''.join(errors)
        print '========================================================================'
        
        raise Exception('There was an error while starting the daemon solver.')
    
    else:
        print '[INFO] SATFC daemon started on port',UDP_PORT,'and ready to go.'
    
    return
    
if __name__ == "__main__":
    main()