#! /usr/bin/env python
# vim: syntax=python

import subprocess
import sys
import os
import tempfile
import time
import socket

version = '0.9.6'
date = 'August 2013'
"""
SAT-based Feasibility checker for FCC's station repacking problem.
Wrapper that communicates with a more parametrized java version of the feasibility checker running as a daemon,
to comform to Ladder Auction Algorithm Mini-Spec v2.1, June 2013 feasibility
checker requirements.

By Auctionomics [Alexandre Frechette, Guillaume Saulnier-Comte, Nick Arnosti,  Kevin Leyton-Brown]


v0.9.1. - The current version has at its core a configured version (March 2013)
of the clasp SAT solver.

@author - Alexandre Frechette
"""

#########################################################################################################

"""Static daemon solver port parameters"""
UDP_IP = "localhost"
UDP_PORT = 49149
MAXPACKETSIZE = 65000

COMMANDSEP = ':'

def processMessage(message):
    command = message.split(COMMANDSEP)[0]
    
    if command == 'PING':
        print '[COMM] Got a PING message.'
        return 'PING'
    elif command == 'ERROR':
        print '[COMM] Got an ERROR message:'
        
        if len(message.split(COMMANDSEP))==2:
            print '[SERVER-ERROR]',message.split(COMMANDSEP)[1]
        else:
            print '(No error info with the error message)'
        return 'ERROR'
    elif command == 'ANSWER':
        print '[COMM] Got an ANSWER message.'
        ##TODO process answer message. 
    elif command == 'TEST':
        print '[COMM] Got a TEST message.'
        print message
    else:
        print '[COMM-ERROR] Unrecognized message:'
        print '[COMM-ERROR]',message
        return 'UNRECOGNIZED'    
    
def sendMessage(sock,message):
    try:
        print '[COMM] Sending',message
        sock.sendto(message.encode('ASCII'), (UDP_IP, UDP_PORT))
    except Exception as e:
        print '[COMM-ERROR] Could not send message to',UDP_IP,'port',UDP_PORT,'('+e.strerror+').'
    
def receiveMessage(sock):
    message, addr = sock.recvfrom(MAXPACKETSIZE)
    print '[COMM] Received a message.'
    return message

    
#########################################################################################################

def main():
    """Check what command must be executed"""
    if len(sys.argv)<=1:
        #Output usage.
        print 'SATFC '+date+', v'+version
        print 'A SAT-based feasibility checker by Auctionomics [A. Frechette, G. Saulnier-Comte, N. Arnosti, K. Leyton-Brown]'
        print 'Normal execution: "./feas_check question_csv_file_name answer_csv_file_name"'
        print 'This wrapper communicates with a SATFC daemon on ',UDP_IP,'port',UDP_PORT
        print 'For more usage see feasibility checker usage section of the Ladder Auction Algorithm Mini-Spec v2.1, June 2013.'
        sys.exit()
    elif sys.argv[1]=='-init':
        """Initialization to perform"""
        print '[INFO] Performing initialization.'
        init()    
        sys.exit()
    elif len(sys.argv)!=3:
        print 'Unrecognized usage, try ./feas_check for some info.'
        sys.exit()
    else:     
        """Instance to solve"""
    
        """Establish connection"""
        try:
            sock = socket.socket(socket.AF_INET, # Internet
                             socket.SOCK_DGRAM) # UDP
        except Exception as e:
            raise Exception('[ERROR] Could not create a UDP socket ('+e.strerror+').')
            sys.exit()
  
        """Ping daemon"""
        print '[INFO] Checking that the daemon SATFC is alive.'
        
        sendMessage(sock,'PING')
        
        pingtime = time.time()
        pinged = False
        while not pinged and time.time()-pingtime < 2:
            message = receiveMessage(sock)
            pinged = (processMessage(message)=='PING')
        if not pinged:
            print '[INFO] Failed to ping daemon SATFC on',UDP_IP,'port',UDP_PORT
            print '[INFO] Reperforming intialization to launch daemon SATFC.'
            
            ##TODO initialization
        
        print '[INFO] Daemon SATFC is alive, proceeding.'
        
        """Create the solving message."""
        
        ##TODO create solving message.
        
        cutoff = 10
        
        print '[INFO] Submitting an instance to the daemon SATFC'
        
        """Send message."""
        
        sendMessage(sock,COMMANDSEP.join(['TEST','Entry1','Entry2','Entry3']))
        
        solvetime = time.time()
        """Wait for answer"""
        while time.time()-solvetime < 1.5*cutoff:           
            message = receiveMessage(sock)
            processMessage(message)
            sys.exit()
             
        print '[ERROR] Did not receive a message from the daemon solver in 1.5*cutofftime ('+str(1.5*cutoff)+') assuming something terrible happened.'
                       
        sys.exit()
        
        
    

    
def getEnvironmentVariables():
    """Environment variables and external settings"""
    #Execution directory of feas_check
    current_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

    #Get the necessary environment variables
    environment_variables = os.environ
    if 'FC_STATION_DATA_PATH' in environment_variables:
        environment_data_location = environment_variables['FC_STATION_DATA_PATH']
    else:
        print '[WARNING] FC_STATION_DATA_PATH environment variable has not been set, resolving to default current directory.'
        environment_data_location = current_dir
    environment_data_location = environment_data_location.rstrip(os.sep)

    if 'FC_WORKING_PATH' in environment_variables:
        environment_execution_dir = environment_variables['FC_WORKING_PATH']
    else:
        print '[WARNING] FC_WORKING_PATH environment variable has not been set, resolving to default current directory.'
        environment_execution_dir = current_dir
    environment_execution_dir = environment_execution_dir.rstrip(os.sep)
    
    return (current_dir,environment_data_location,environment_execution_dir)
    
def getSolvingInstanceInfo(environment_data_location):
    """Parse FCC feas_check parameters"""

    question_filename = environment_execution_dir+os.sep+sys.argv[1]
    answer_filename = environment_execution_dir+os.sep+sys.argv[2]

    #Parse the question parameters
    question_parameters = {}
    question_file = open(question_filename,'r')
    question_lines = question_file.readlines()
    question_file.close()

    question_parameters = {'FC_TIMEOUT':[],'FC_CONFIG':[],'STATION_CONFIG':[],'BAND':[],'HIGHEST':[],'STATIONS':[]}

    for question_line in question_lines:
        question_line = question_line.replace('\n','')
        key = question_line.split(',')[0]
        if key in question_parameters.keys():
            question_parameters[key].append(question_line.split(',')[1])
        elif key.isdigit():
            question_parameters['STATIONS'].append(question_line)
        elif key:
            raise Exception('Unrecognized problem instance data key in question csv file! ('+question_line+')')

    #Map to options for feasibility checker.
    try:
        cutoff = str(float(question_parameters['FC_TIMEOUT'][0])/1000.0)
    except:
        raise Exception('Unrecognized value for key FC_TIMEOUT in question csv file!')

    #Directory to find problem setting data
    problem_data_directory = 'default'
    if len(question_parameters['STATION_CONFIG'])>0:
        problem_data_directory = question_parameters['STATION_CONFIG'][0]
    problem_data_directory = environment_data_location+os.sep+problem_data_directory

    #Channels to pack into.
    if question_parameters['BAND'][0]=='LVHF':
        packing_channels = range(2,6+1)
    elif question_parameters['BAND'][0]=='HVHF' or question_parameters['BAND'][0]=='UVHF':
        packing_channels = range(7,13+1)
    elif question_parameters['BAND'][0]=='UHF':

        highest_channel = 51
        if len(question_parameters['HIGHEST'])>0:
            try:
                highest_channel = int(question_parameters['HIGHEST'][0])
            except:
                raise Exception('Unrecognized value for key HIGHEST in question csv file! (value ='+question_parameters['HIGHEST']+')')

        packing_channels = range(14,min(highest_channel,51)+1)
        if 37 in packing_channels:
            packing_channels.remove(37)
    else:
        raise Exception('Unrecognized value for key BAND in question csv file! (value = '+question_parameters['BAND']+')')
    packing_channels = ','.join(map(lambda c : str(c),packing_channels))

    #Stations to pack
    try:
        packing_stations = [int(line.split(',')[0]) for line in question_parameters['STATIONS']]
    except:
        raise Exception('Unrecognized list of stations in question csv file! ('+question_parameters['STATIONS']+')')
    packing_stations = ','.join(map(lambda s : str(s),packing_stations))
    
    return (problem_data_directory,packing_stations,packing_channels,cutoff)

def init(current_dir,environment_execution_dir):
    #Perform initialization
    
    #TODO Check if Daemon is alive.
    
    #Directory to put CNF's an other SAT execution data.
    cnf_dir = environment_execution_dir + os.sep + 'CNFs'
    #Check if the cnf folder exists, if not create it
    if not os.path.exists(cnf_dir):
        print '[WARNING] There was no CNF folder in the provided execution directory, created one.'
        os.makedirs(cnf_dir)
    
    #Navigate the current directory for data folders.
    
    
    """Fill in the SATFC options and launch it"""
    #print 'Creating the callstring to the feasibility checker...'

    solver = 'tunedclasp'

    options = {
    "-DOMAINS_FILE":
    domains_filename,
    "-CONSTRAINTS_FILE":
    interference_filename,
    "-CNF_DIR":
    cnf_dir,
    "-SAT-SOLVER-TYPE":
    "TAE",
    "-SOLVER":
    solver,
    "--execDir":
    current_dir+os.sep+"SATsolvers",
    "--algoExec":
    '"python solverwrapper.py"',
    "-CUTOFF":
    cutoff,
    "--cutoffTime":
    cutoff,
    "--logAllCallStrings":
    "true",
    "-PACKING_CHANNELS":
    packing_channels,
    "-PACKING_STATIONS":
    packing_stations,
    "--logAllCallStrings":
    "true"
    }
    
    feas_check_exec = 'java -jar '+current_dir+os.sep+'SATFC.jar'
    options_callstring = ' '.join(map(lambda (k,v) : k+' '+v,options.iteritems()))

    callstring = feas_check_exec+' '+options_callstring
    
    print callstring
    
    execution = subprocess.Popen(callstring.split(' '),stdout=temp_stdout,stderr=temp_stderr)
    
    
if __name__ == "__main__":
    main()